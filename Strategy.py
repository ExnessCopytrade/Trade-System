# Strategy.py

import datetime
import numpy as np
import pandas as pd

from abc import ABCMeta, abstractmethod

from Event import SignalEvent

class Strategy(object):
    """
    Strategy is an abstract base class providing an interface for
    all subsequent (inherited) strategy handling objects.

    The goal of a (derived) Strategy object is to generate Signal
    objects for particular symbols based on the inputs of Bars
    (OLHCVI) generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Strategy object is agnostic to the data source,
    since it obtains the bar tuples from a queue object.
    """

    __metaclass__ = ABCMeta

    @abstractmethod
    def calculate_signals(self):
        """
        Provides the mechanisms to calculate the list of signals.
        """
        raise NotImplementedError("Should implement calculate_signals()")

class BuyAndHoldStrategy(Strategy):
    """
    This is an extremely simple strategy that goes LONG all of the
    symbols as soon as a bar is received. It will never exit a position.

    It is primarily used as a testing mechanism for the Strategy class
    as well as a benchmark upon which to compare other strategies.
    """

    def __init__(self, bars, events):
        """
        Initialises the buy and hold strategy.

        Parameters:
        bars - The DataHandler object that provides bar information
        events - The Event Queue object.
        """
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events

        # Once buy & hold signal is given, these are set to True
        self.bought = self._calculate_initial_bought()

    def _calculate_initial_bought(self):
        """
        Adds keys to the bought dictionary for all symbols
        and sets them to False.
        """
        bought = {}
        for s in self.symbol_list:
            bought[s] = False
        return bought

    def calculate_signals(self, event):
        """
        For "Buy and Hold" we generate a single signal per symbol
        and then no additional signals. This means we are
        constantly long the market from the date of strategy
        initialisation.

        Parameters
        event - A MarketEvent object.
        """
        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars(s, N=1)
                if bars is not None and bars != []:
                    if self.bought[s] == False:
                        # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                        signal = SignalEvent(bars[0][0], bars[0][1], 'LONG')
                        self.events.put(signal)
                        self.bought[s] = True

class SMACrossover(Strategy):
    '''
    Simple Moving Average Crossover
    SELL SHORT if the 5MA crossed below the 20MA between the last two full bars
    BUY LONG if the 5MA crosses above the 20MA between the last two full bars
    Hold each position for one period (deal with close somewhere else?)
    '''

    def __init__(self, bars, events):
        self.bars = bars
        self.events = events
        self.slow = 20 # the longer period
        self.fast = 5 # the Shorter period

    def calculate_signals(self, event):
        '''
        Generate a single signal since we are dealing with a single symbol
        '''
        # close logic here? implement later
        try:
            s1 = SMA_back1(self.slow)
            f1 = SMA_back1(self.fast)
            s2 = SMA(self.slow)
            f2 = SMA(self.fast)
        except:
            return
        else:
            if s1 < f1 and s2 > f2:
                # cross below
                self.events.append(SignalEvent(None, bars.get_latest_bars(N=1)[0][0], 'SHORT'))
            elif s1 > f1 and s2 < f2:
                # cross above
                self.events.append(SignalEvent(None, bars.get_latest_bars(N=1)[0][0], 'LONG'))

    # eventually I will generalize my strategy and
    # move my indicators into their own class to be more flexible
    # i hope these work correctly
    def SMA(p):
        # first check that there are enough bars to calculate
        b = bars.get_latest_bars(p)
        if len(b) < p:
            raise Exception

        accum = 0
        for date,open,high,low,close,adj,vol in b:
            accum += close
        return accum/p

    def SMA_back1(p):
        # first check that there are enough bars to calculate
        b = bars.get_latest_bars(p+1)
        if len(b) < p+1:
            raise Exception

        accum = 0
        for date,open,high,low,close,adj,vol in b[:-1]:
            accum += close
        return accum/p

class SimpleBuy(Strategy):
    '''
    A simple strategy that goes long, holds for 1 period, then closes.
    '''
    def __init__(self, bars, events):
        self.bars = bars
        self.symbol_list = self.bars.symbol_list
        self.events = events

    def calculate_signals(self, event):
        '''
        exit the previous position and enter a new one
        '''
        if event.type == 'MARKET':
            for s in self.symbol_list:
                bars = self.bars.get_latest_bars(s, N=1)
                if bars is not None and bars != []:
                    # (Symbol, Datetime, Type = LONG, SHORT or EXIT)
                    events.append(SignalEvent(bars[0][0], bars[0][1], 'EXIT'))
                    events.append(SignalEvent(bars[0][0], bars[0][1], 'LONG'))
